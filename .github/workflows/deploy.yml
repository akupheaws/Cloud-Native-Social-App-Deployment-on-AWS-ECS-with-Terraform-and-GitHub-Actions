name: Deploy (Root Dockerfile & Context + ECR import-if-exists)

on:
  push:
    branches: ["main"]
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  PROJECT_NAME: Social App              # <-- change to "socialapp" if using the social app stack
  TF_STATE_KEY: terraform.tfstate
  DOCKERFILE: Dockerfile               # root-level Dockerfile
  BUILD_CONTEXT: .                     # root-level context
  ECR_REPO_NAME: akuphe-socialapp-repo # <-- change if you want a different ECR repo
  LOCK_TABLE_NAME: tf-locks

concurrency:
  group: deploy-2048
  cancel-in-progress: false

defaults:
  run:
    shell: bash

jobs:
  bootstrap_state:
    name: Bootstrap backend (S3 + DynamoDB)
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Configure AWS (access keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Compute valid bucket name
        id: bk
        run: |
          REPO_SLUG="${{ github.repository }}"
          SLUG_LOWER=$(echo "$REPO_SLUG" | tr '[:upper:]' '[:lower:]')
          BASE=$(echo "$SLUG_LOWER" | sed -E 's/[^a-z0-9-]/-/g; s/-+/-/g; s/^-+//; s/-+$//')
          BASE=${BASE:0:32}
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          SUFFIX=$(printf '%s' "$SLUG_LOWER" | sha1sum | cut -c1-8)
          BUCKET="${BASE}-${ACCOUNT_ID}-${SUFFIX}-tf"
          BUCKET=$(echo "$BUCKET" | sed -E 's/^-+//; s/-+$//')
          test -n "$BUCKET" || { echo "Bucket empty"; exit 1; }
          echo "bucket_name=$BUCKET" >> "$GITHUB_OUTPUT"
          echo "Bucket: $BUCKET (len=$(echo -n $BUCKET | wc -c))"

      - name: Create S3 bucket (if missing)
        env:
          BUCKET: ${{ steps.bk.outputs.bucket_name }}
        run: |
          if ! aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            if [ "$AWS_REGION" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "$BUCKET"
            else
              aws s3api create-bucket --bucket "$BUCKET" --region "$AWS_REGION" \
                --create-bucket-configuration LocationConstraint="$AWS_REGION"
            fi
            aws s3api put-bucket-versioning --bucket "$BUCKET" --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket "$BUCKET" --server-side-encryption-configuration '{
              "Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
            aws s3api put-public-access-block --bucket "$BUCKET" --public-access-block-configuration '{
              "BlockPublicAcls":true,"IgnorePublicAcls":true,"BlockPublicPolicy":true,"RestrictPublicBuckets":true}'
          fi

      - name: Create DynamoDB lock table (if missing)
        run: |
          if ! aws dynamodb describe-table --table-name "${LOCK_TABLE_NAME}" >/dev/null 2>&1; then
            aws dynamodb create-table --table-name "${LOCK_TABLE_NAME}" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
            aws dynamodb wait table-exists --table-name "${LOCK_TABLE_NAME}"
          fi

    outputs:
      tf_bucket: ${{ steps.bk.outputs.bucket_name }}

  seed_ecr:
    name: Ensure ECR exists (import if exists, else create)
    runs-on: ubuntu-latest
    needs: bootstrap_state
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Compute valid bucket name (this job)
        id: bk
        run: |
          REPO_SLUG="${{ github.repository }}"
          SLUG_LOWER=$(echo "$REPO_SLUG" | tr '[:upper:]' '[:lower:]')
          BASE=$(echo "$SLUG_LOWER" | sed -E 's/[^a-z0-9-]/-/g; s/-+/-/g; s/^-+//; s/-+$//')
          BASE=${BASE:0:32}
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          SUFFIX=$(printf '%s' "$SLUG_LOWER" | sha1sum | cut -c1-8)
          BUCKET="${BASE}-${ACCOUNT_ID}-${SUFFIX}-tf"
          BUCKET=$(echo "$BUCKET" | sed -E 's/^-+//; s/-+$//')
          test -n "$BUCKET" || { echo "Bucket empty"; exit 1; }
          echo "bucket_name=$BUCKET" >> "$GITHUB_OUTPUT"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Write backend.hcl
        working-directory: terraform
        run: |
          cat > backend.hcl <<EOF
          bucket         = "${{ steps.bk.outputs.bucket_name }}"
          key            = "${{ env.TF_STATE_KEY }}"
          region         = "${{ env.AWS_REGION }}"
          dynamodb_table = "${{ env.LOCK_TABLE_NAME }}"
          encrypt        = true
          EOF
          cat backend.hcl

      - name: Terraform Init
        working-directory: terraform
        run: terraform init -reconfigure -backend-config=backend.hcl

      - name: Ensure ECR exists and is in TF state (import if exists, else create)
        working-directory: terraform
        run: |
          set -e
          REPO="${ECR_REPO_NAME}"
          if terraform state show aws_ecr_repository.app >/dev/null 2>&1; then
            echo "Terraform state already has aws_ecr_repository.app"
          else
            if aws ecr describe-repositories --repository-names "$REPO" >/dev/null 2>&1; then
              echo "ECR '$REPO' exists; importing into Terraform state."
              terraform import -input=false aws_ecr_repository.app "$REPO"
            else
              echo "ECR '$REPO' not found; creating via targeted apply."
              terraform apply -auto-approve \
                -target=aws_ecr_repository.app \
                -var="region=${AWS_REGION}" \
                -var="ecr_repo_name=${ECR_REPO_NAME}"
            fi
          fi

      - name: Get ECR repo URL (output or compute)
        id: out
        working-directory: terraform
        run: |
          URI="$(terraform output -raw ecr_repository_url 2>/dev/null || true)"
          if [ -z "$URI" ] || [ "$URI" = "null" ]; then
            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"
          fi
          echo "ecr_url=$URI" >> "$GITHUB_OUTPUT"
          echo "ECR URL: $URI"

    outputs:
      ecr_url: ${{ steps.out.outputs.ecr_url }}

  build_and_push:
    name: Build & push Docker image (latest + SHA)
    runs-on: ubuntu-latest
    needs: seed_ecr
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure Docker uses default context
        run: |
          docker context use default || true
          unset DOCKER_CONTEXT || true

      - name: Derive ECR registry + repo (robust)
        id: ecr
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          REPO_URL="${{ needs.seed_ecr.outputs.ecr_url }}"
          if [ -z "$REPO_URL" ]; then
            REPO_URL="${REGISTRY}/${ECR_REPO_NAME}"
          fi
          echo "registry=$REGISTRY" >> "$GITHUB_OUTPUT"
          echo "repo_url=$REPO_URL" >> "$GITHUB_OUTPUT"
          echo "Resolved registry: $REGISTRY"
          echo "Resolved repo_url: $REPO_URL"

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION" \
            | docker login --username AWS --password-stdin "${{ steps.ecr.outputs.registry }}"

      - name: Locate Dockerfile & context (with auto-fallback)
        id: locate
        run: |
          if [ -f "$DOCKERFILE" ] && { [ -d "$BUILD_CONTEXT" ] || [ "$BUILD_CONTEXT" = "." ]; }; then
            DF="$DOCKERFILE"; CTX="$BUILD_CONTEXT"
          else
            echo "Configured paths not found. Auto-detecting..."
            DF=$(git ls-files | grep -E '(^|/)Dockerfile$' | head -n1 || true)
            if [ -z "$DF" ]; then
              echo "No Dockerfile found in repository." >&2
              exit 1
            fi
            CTX=$(dirname "$DF")
            [ -z "$CTX" ] && CTX="."
          fi
          echo "dockerfile=$DF" >> "$GITHUB_OUTPUT"
          echo "context=$CTX" >> "$GITHUB_OUTPUT"
          echo "Using Dockerfile: $DF"
          echo "Using build context: $CTX"

      - name: Build
        run: docker build -f "${{ steps.locate.outputs.dockerfile }}" -t app:${{ github.sha }} "${{ steps.locate.outputs.context }}"

      - name: Tag & push (latest + SHA)
        run: |
          REPO="${{ steps.ecr.outputs.repo_url }}"
          docker tag app:${{ github.sha }} "$REPO":${{ github.sha }}
          docker tag app:${{ github.sha }} "$REPO":latest
          docker push "$REPO":${{ github.sha }}
          docker push "$REPO":latest

  plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: [bootstrap_state, build_and_push]
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Compute valid bucket name (this job)
        id: bk
        run: |
          REPO_SLUG="${{ github.repository }}"
          SLUG_LOWER=$(echo "$REPO_SLUG" | tr '[:upper:]' '[:lower:]')
          BASE=$(echo "$SLUG_LOWER" | sed -E 's/[^a-z0-9-]/-/g; s/-+/-/g; s/^-+//; s/-+$//')
          BASE=${BASE:0:32}
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          SUFFIX=$(printf '%s' "$SLUG_LOWER" | sha1sum | cut -c1-8)
          BUCKET="${BASE}-${ACCOUNT_ID}-${SUFFIX}-tf"
          BUCKET=$(echo "$BUCKET" | sed -E 's/^-+//; s/-+$//')
          test -n "$BUCKET" || { echo "Bucket empty"; exit 1; }
          echo "bucket_name=$BUCKET" >> "$GITHUB_OUTPUT"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Write backend.hcl
        working-directory: terraform
        run: |
          cat > backend.hcl <<EOF
          bucket         = "${{ steps.bk.outputs.bucket_name }}"
          key            = "${{ env.TF_STATE_KEY }}"
          region         = "${{ env.AWS_REGION }}"
          dynamodb_table = "${{ env.LOCK_TABLE_NAME }}"
          encrypt        = true
          EOF
          cat backend.hcl

      - name: Terraform Init
        working-directory: terraform
        run: terraform init -reconfigure -backend-config=backend.hcl

      - name: Terraform fmt & validate
        working-directory: terraform
        run: |
          terraform fmt -check -recursive
          terraform validate

      - name: Terraform Plan (with image tag)
        working-directory: terraform
        env:
          TF_VAR_session_secret: ${{ secrets.SOCIALAPP_SESSION_SECRET }}
        run: |
          EXTRA=""
          # Only pass session_secret if the secret is configured; avoids overriding TF default with empty
          if [ -n "${TF_VAR_session_secret}" ]; then
            EXTRA='-var="session_secret=${TF_VAR_session_secret}"'
          fi
          terraform plan \
            -var="region=${{ env.AWS_REGION }}" \
            -var="image_tag=${{ github.sha }}" \
            -var="ecr_repo_name=${{ env.ECR_REPO_NAME }}" \
            $EXTRA

  apply:
    name: Terraform Apply (deploy)
    runs-on: ubuntu-latest
    needs: plan
    permissions:
      contents: read
    outputs:
      alb: ${{ steps.resolve.outputs.alb }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Compute valid bucket name (this job)
        id: bk
        run: |
          REPO_SLUG="${{ github.repository }}"
          SLUG_LOWER=$(echo "$REPO_SLUG" | tr '[:upper:]' '[:lower:]')
          BASE=$(echo "$SLUG_LOWER" | sed -E 's/[^a-z0-9-]/-/g; s/-+/-/g; s/^-+//; s/-+$//')
          BASE=${BASE:0:32}
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          SUFFIX=$(printf '%s' "$SLUG_LOWER" | sha1sum | cut -c1-8)
          BUCKET="${BASE}-${ACCOUNT_ID}-${SUFFIX}-tf"
          BUCKET=$(echo "$BUCKET" | sed -E 's/^-+//; s/-+$//')
          test -n "$BUCKET" || { echo "Bucket empty"; exit 1; }
          echo "bucket_name=$BUCKET" >> "$GITHUB_OUTPUT"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Write backend.hcl
        working-directory: terraform
        run: |
          cat > backend.hcl <<EOF
          bucket         = "${{ steps.bk.outputs.bucket_name }}"
          key            = "${{ env.TF_STATE_KEY }}"
          region         = "${{ env.AWS_REGION }}"
          dynamodb_table = "${{ env.LOCK_TABLE_NAME }}"
          encrypt        = true
          EOF
          cat backend.hcl

      - name: Terraform Init
        working-directory: terraform
        run: terraform init -reconfigure -backend-config=backend.hcl

      - name: Terraform Apply (with image tag)
        working-directory: terraform
        env:
          TF_VAR_session_secret: ${{ secrets.SOCIALAPP_SESSION_SECRET }}
        run: |
          EXTRA=""
          if [ -n "${TF_VAR_session_secret}" ]; then
            EXTRA='-var="session_secret=${TF_VAR_session_secret}"'
          fi
          terraform apply -auto-approve \
            -var="region=${{ env.AWS_REGION }}" \
            -var="image_tag=${{ github.sha }}" \
            -var="ecr_repo_name=${{ env.ECR_REPO_NAME }}" \
            $EXTRA

      - name: Wait for ECS service stable
        run: |
          aws ecs wait services-stable \
            --cluster "${PROJECT_NAME}-cluster" \
            --services "${PROJECT_NAME}-svc"

      - name: Resolve ALB DNS (tf output -> AWS CLI fallback)
        id: resolve
        working-directory: terraform
        run: |
          set -e
          ALB="$(terraform output -raw alb_dns_name || true)"
          if [ -z "$ALB" ]; then
            NAME="${PROJECT_NAME}-alb"
            ALB=$(aws elbv2 describe-load-balancers --names "$NAME" \
              --query 'LoadBalancers[0].DNSName' --output text 2>/dev/null || true)
          fi
          if [ -z "$ALB" ] || [ "$ALB" = "None" ]; then
            echo "Failed to resolve ALB DNS name" >&2
            aws elbv2 describe-load-balancers --query 'LoadBalancers[].{Name:LoadBalancerName,DNS:DNSName}' --output table || true
            exit 1
          fi
          echo "alb=$ALB" >> "$GITHUB_OUTPUT"
          echo "Resolved ALB: $ALB"

  smoke_test:
    name: Smoke test
    runs-on: ubuntu-latest
    needs: apply
    permissions:
      contents: read
    steps:
      - name: Determine ALB URL
        id: pick
        run: |
          URL="http://${{ needs.apply.outputs.alb }}"
          echo "url=$URL" >> "$GITHUB_OUTPUT"
          echo "Resolved URL: $URL"

      - name: Fail fast if URL is empty
        run: |
          if [ "${{ steps.pick.outputs.url }}" = "http://" ] || [ -z "${{ steps.pick.outputs.url }}" ]; then
            echo "ALB URL is empty. Please check the apply job logs for 'Resolved ALB:' lines." >&2
            exit 1
          fi

      - name: Curl homepage until 200
        run: |
          URL="${{ steps.pick.outputs.url }}"
          echo "Hitting $URL"
          for i in {1..30}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || true)
            if [ "$code" = "200" ]; then
              echo "OK (200) at $URL"
              exit 0
            fi
            echo "Attempt $i -> $code"
            sleep 5
          done
          echo "Service did not return 200 in time"
          exit 1
